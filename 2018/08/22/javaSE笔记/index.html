






<!doctype html>
<html lang="">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Alan Haze">
  
  
  
  
    <meta name="description" content="java程序的初始化一般遵循3个原则（优先级依次递减）：1. 静态对象（变量）优先于非静态对象（变量）初始化。2. 父类优先于子类进行初始化。3. 按照成员变量的定义顺序进行初始化。

只有public、abstract或者final可以用来修饰类。


重载和覆盖的区别：
重载是一个类里面,函数名相同但参数列表不同的函数，不能通过方法的访问权限、返回值类型和抛出异常类型来进行重载。
而覆盖...">
  
  <title>JavaSE笔记 [ AlanHaze's blog ]</title>
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
  
    <div class="item next">
      <a href="/2018/08/12/Linux常用命令/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        Linux常用命令
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/volvo.jpg"/>
          <div id="homelink">AlanHaze's blog</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">Home</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">Archives</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">Tags</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">Categories</a>
            
          </li>
        
          
            <li>
          
            <a href="https://github.com/stiekel/hexo-theme-random">About</a>
            
          </li>
        
          
            <li>
          
            <a href="https://github.com/AlanHaze">Github</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  <article id="post">
    <h1>JavaSE笔记</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">Created at 2018-08-22</span>
      
        <span id = "post-title-updated">Updated at 2018-08-22</span>
      
      
      
      <span id = "post-title-tags">
      Tag
      
      
        
        
        <a href="/tags/JavaSE/">JavaSE</a>
      
      </span>
      
    </p>
    
    <ul>
<li><p>java程序的初始化一般遵循3个原则（优先级依次递减）：1. 静态对象（变量）优先于非静态对象（变量）初始化。2. 父类优先于子类进行初始化。3. 按照成员变量的定义顺序进行初始化。</p>
</li>
<li><p>只有public、abstract或者final可以用来修饰类。</p>
</li>
</ul>
<h4 id="重载和覆盖的区别："><a href="#重载和覆盖的区别：" class="headerlink" title="重载和覆盖的区别："></a>重载和覆盖的区别：</h4><ol>
<li>重载是一个类里面,函数名相同但参数列表不同的函数，不能通过方法的访问权限、返回值类型和抛出异常类型来进行重载。</li>
<li>而覆盖是子类类重写了父类的函数，且需要有相同的函数名、参数列表、返回值类型、抛出的异常类型都需要相同；如在继承中，父类定义了一个private方法，而子类也定义了一个同名函数，那这是一个新的方法，而不是重载；<h5 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h5><ol>
<li>覆盖是子类和父类之间的关系，属垂直关系；重载是一个类中方法之间的关系，属水平关系；</li>
<li>覆盖只能由一个方法或只对一个方法产生关系，而重载是多个方法之间的关系；</li>
<li>覆盖要求参数列表相同，重载则是要求不同；</li>
<li>覆盖关系中，调用方法体是根据对象的类型来决定，而重载关系是根据调用时的实参表与形参表来选择方法体的；</li>
</ol>
</li>
</ol>
<ul>
<li>在父类没有提供无参数的构造函数时，子类的构造函数必须显式的调用父类构造函数。如果父类提供了无参数构造器则可以不显式的调用父类的构造函数，在这种情况下编译器会默认调用父类提供的无参数构造函数。当有父类时，在实例化对象时会先执行父类的构造函数，然后再执行子类的构造函数。</li>
</ul>
<h4 id="接口与抽象类："><a href="#接口与抽象类：" class="headerlink" title="接口与抽象类："></a>接口与抽象类：</h4><p>抽象类：</p>
<ol>
<li>只要包含一个抽象方法的类就必须声明为抽象类，被声明的抽象方法不能包含方法体；</li>
<li>实现类实现时，必须包含相同的或者更低的访问级别（public—&gt;protected—&gt;private）；</li>
<li>抽象类在使用过程中不能被实例化，但是可以创建一个对象使其指向具体子类的一个实例；</li>
<li>抽象类的子类为父类的所有抽象方法提供具体实现，否则他们也是抽象类；</li>
<li>抽象类可以包含部分方法的实现；</li>
</ol>
<p>接口：</p>
<ol>
<li>接口是特殊的抽象类；</li>
<li>接口中的所有方法都是抽象的；</li>
<li>接口中的成员变量都是static final类型；</li>
</ol>
<p>共同点：</p>
<ol>
<li>都不能被实例化；</li>
<li>接口的实现类或者抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化；</li>
</ol>
<p>不同点：</p>
<ol>
<li>接口只能定义方法，不能提供方法的实现，只有实现类才能实现接口中的方法；抽象类中可以有定义可以有实现；</li>
<li>接口需要实现（implements），抽象类只能被继承（extends）；</li>
<li>接口强调特定功能的实现，设计理念为“has-a”关系；抽象类强调所属关系，设计理念为“is-a”关系；</li>
<li>接口中定义的成员变量默认为<em>public static final</em>，<em>只能够有静态的不能被修改的数据成员，且必须给其赋值</em>，其所有<em>成员方法都是public abstract的</em>，而且只能够被<em>这两个关键字</em>修饰；抽象类可以有<em>自己的数据成员变量</em>，也可以有非抽象的成员方法，而且抽象类中的<em>成员变量默认为default（本包可见）</em>，当然也可以被定义为private、protected和public，这些成员变量可以在子类中被重新定义，也可以被重新赋值，抽象类中的抽象方法（必须有abstract修饰）不能用private、static、synchronized、native（Native Method就是一个java调用非java代码的接口）等访问修饰符，同时方法只能以分号结尾，且不能带花括号；</li>
<li>接口被用于实现比较常用的功能，便于日后维护或者添加删除方法；抽象类更倾向与充当公共类的角色，不适用于日后对里面的代码进行修改；</li>
</ol>
<p>总结：</p>
<ol>
<li>接口时一种特殊的抽象类，使用接口完全有可能实现与抽象类相同的操作；</li>
<li>当子类和父类之间存在有逻辑上的层次结构时，使用抽象类；</li>
<li>不同类之间，定义不同类之间的通信规则、希望支持两个差别较大或者更多对象之间特定的交互行为时，使用接口；</li>
<li>接口可以继承接口，抽象类可以实现接口，抽象类也可以继承具体类，抽象类可以有main方法（接口不能）。</li>
</ol>
<h4 id="什么时候使用抽象类和接口？"><a href="#什么时候使用抽象类和接口？" class="headerlink" title="什么时候使用抽象类和接口？"></a>什么时候使用抽象类和接口？</h4><ol>
<li>如果拥有一些方法并且想让它们中的一些有默认实现，使用抽象类。</li>
<li>如果想实现多重继承，只能使用接口。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ol>
<ul>
<li><p>如一个接口中没有任何方法，就叫做标识接口，标识接口对于实现它的类没有任何语义上的要求，仅作标识用，java中已存在的标识接口有Cloneable和Serializable等，在使用时可以使用instanceof来判断该实例对象是否实现了一个给定的接口。</p>
</li>
<li><p>为了解决C/C++中指针带来的不便，java取消了指针的概念，但这只是在java语言中没有明确提供指针的概念和用法，而实质上每次使用new语句返回的都是一个指针的引用，只是无需开发人员关心而已。</p>
</li>
<li><p>Object类中提供一个clone（）方法，该方法可返回一个对象的复制而非该对象的引用，且存在深复制与浅复制之分。</p>
</li>
<li><p>反射机制所能提供的功能主要有：获取一个类的所有成员变量和方法；在运行时动态的创建类的对象；在运行时调用对象的方法；获取class类的方法有三种（1）class.forname(“类的路径”)（2）类名.class（3）该类实例.getClass()。所以创建类有四种方法：new语句；反射机制；clone（）方法；反序列化；</p>
</li>
</ul>
<h4 id="面向对象的主要特征包括抽象、继承、封装和多态："><a href="#面向对象的主要特征包括抽象、继承、封装和多态：" class="headerlink" title="面向对象的主要特征包括抽象、继承、封装和多态："></a>面向对象的主要特征包括抽象、继承、封装和多态：</h4><ol>
<li>抽象：抽象就是忽略一个主题与当前目标无关的方面，主要关注与当前目标有关的方面。抽象包括两个方面：一个是过程抽象；一个是数据抽象。</li>
<li>继承：对象的一个新类可以从现有的类中派生，这个过程成为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始的类成为新类的基类（父类），派生类可以从它的父类中继承方法和实例变量，并且子类可以修改或增加新的方法使之更适合特殊的需要。</li>
<li>封装：封装是指将客观事物抽象成类，每个类对自身的数据和方法实行保护。类可以可以把自己的数据和方法只让可信任的类和对象进行操作，对不可信的进行信息隐藏。</li>
<li>多态：多态是指允许不同类的对象对同一消息做出响应。多态性语言具有灵活、抽象、行为共享、代码共享等优势，很好的解决了应用程序函数同名的问题。</li>
</ol>
<h4 id="继承有如下特点："><a href="#继承有如下特点：" class="headerlink" title="继承有如下特点："></a>继承有如下特点：</h4><ol>
<li>java不支持多继承，但可以通过实现多个接口来达到多重继承的目的。</li>
<li>子类只能继承父类的非私有（public和protected）成员变量和方法。</li>
<li>当子类中定义的成员变量和父类中定义的成员变量同名时，子类中的成员变量会覆盖父类的成员变量，而不会继承。</li>
<li>当子类中的方法和父类中的方法有相同的函数签名（相同的方法名，相同的参数列表）时，子类会覆盖父类的方法，而不会继承。</li>
</ol>
<p>Tips：</p>
<ol>
<li>除非两个类是“is-a”关系否则不要轻易使用继承，不要单纯为了实现代码的重用而使用继承，因为过多的使用继承会破坏代码的可维护性，当父类被修改时，会影响到所有继承自它的子类，从而增加程序的维护难度和成本。</li>
<li>不要仅仅为了实现多态而使用继承，如果类之间没有“is-a”关系可以考虑使用接口和组合来达到相同的目的，还可拥有更好的扩展性。能使用组合就尽量不要使用继承！</li>
</ol>
<h4 id="多态的实现机制："><a href="#多态的实现机制：" class="headerlink" title="多态的实现机制："></a>多态的实现机制：</h4><ol>
<li>方法的重载：拥有不同参数列表的重载方法，是在编译时确定到底采用那个方法，是一种编译时多态。</li>
<li>方法的覆盖：子类覆盖父类的方法，因此同样的方法就有了不同的表现形式，父类的引用变量不仅可以指向父类的实例对象，还能指向子类的实例对象，同样，接口的引用变量也能指向实现类的实例对象，而程序调用的方法在运行期间才动态绑定，就是应用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法，由于只有在运行时才能确定调用哪个方法，所以通过方法覆盖实现的多态也可以被称为运行时多态。</li>
</ol>
<p>Tips：只有类中的方法才有多态概念，类中的成员变量是没有多态的概念的。成员变量的取值并不取决于创建对象的类型，而是取决于所定义变量的类型。</p>
<ul>
<li><p>内部类分四种：静态内部类（satatic inner class）（不能访问外部类普通成员变量）、成员内部类（member inner class）、局部内部类（local inner class）、匿名内部类（anonymous inner class）；所有非静态内部类不能有静态成员；</p>
</li>
<li><p>如何获取父类类名：用super.getClass().getName()获取的依旧是子类的类名，因为最终调用的是Object类中的getClass()方法，而此方法的释义是返回此Object的运行时的类名，所以应该使用this.getSuperclass().getname()方法；</p>
</li>
<li><p>this.变量名代表所在类中的成员变量；当子类和父类的方法和成员变量同名时会覆盖父类中的方法和成员变量，只能通过super关键字访问父类中的方法和成员变量；</p>
</li>
<li><p>当子类构造函数需要显式调用父类构造函数时，super（）必须作为构造函数中的第一条语句；</p>
</li>
<li><p>标识符不能以数字开头、不能有空格、不能使用关键字和保留字、不能包含“ * ”； </p>
</li>
</ul>
<h4 id="break、continue以及return的区别："><a href="#break、continue以及return的区别：" class="headerlink" title="break、continue以及return的区别："></a>break、continue以及return的区别：</h4><ol>
<li>break用于强行跳出当前循环，不再执行剩余代码，跳出循环体执行下面的语句；</li>
<li>continue用于停止当次循环，之后的语句不再执行，回到循环起始处进入下一次循环操作。一般用于跳过循环中的一部分语句；</li>
<li>return语句是一个跳转语句，表示从一个方法返回（一个值或者其他复杂类型），可以使程序返回到调用该方法的地方。当main方法中有return时，程序返回到java运行系统；</li>
</ol>
<ul>
<li>可以在循环体外定义一个标签（标签名 + “:”），使用break关键字后可以跳到该处继续执行程序；</li>
</ul>
<h4 id="final、finally和finalize的区别："><a href="#final、finally和finalize的区别：" class="headerlink" title="final、finally和finalize的区别："></a>final、finally和finalize的区别：</h4><ol>
<li><p>final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承。</p>
<ol>
<li>final属性：被其修饰的变量不可变。由于不可变有两重含义：一是引用不可变（指向初始时的那个对象，对象内容不关心）；二是对象不可变（对象内容不可变），被final修饰的变量是引用不可变（如final StringBuffer依旧可以append），但在声明该变量时必须初始化（不能在静态初始化块中初始化。static修饰的就可以，但其就不能在非静态初始块中初始化）。</li>
<li>final方法：当一个方法声明为final时，该方法不可被任何子类重写，但子类可以使用该方法。</li>
<li>final类：当一个类被声明为final时，该类不可被继承，所有方法不得被重写（但其成员变量并非final，需自行添加final进行修饰）。Tips：一个类不可既被声明为abstract，又被声明为final。</li>
</ol>
</li>
<li><p>finally是异常处理的一部分，通常用在try/catch语句中，表示finally语句块中的语句一定会执行。</p>
</li>
<li>finalize是Object类中的一个方法，在垃圾回收器执行时会调用被回收对像的finalize（）方法，可以覆盖此方法来实现对其他资源的回收。Tips：一旦垃圾回收器准备好释放对像占用的空间，将首先调用其finalize（）方法，并在下一次垃圾回收器动作发生时，才会真正回收该对象的内存。</li>
</ol>
<ul>
<li>作用：是用于对程序进行调试的，对于执行结构的判断，而不是对于业务流程的判断。（相当于一个if ()语句，如果满足断言的执行程序，如果不满足则抛错误），只适用复杂的调式过程。</li>
</ul>
<h4 id="Static关键字的作用"><a href="#Static关键字的作用" class="headerlink" title="Static关键字的作用"></a>Static关键字的作用</h4><p>主要有两个作用，第一：为模特定数据类型或对象分配单一的存储空间，与创建对象的个数无关。第二：实现某个方法和属性与类而不是与对象关联在一起，从而可以在不创建对象的情况下调用方法。static主要有4种使用情况：成员变量、成员方法、代码块和内部类。</p>
<ol>
<li>static修饰的成员变量属于类，在内存中只有一个复制（所有实例都指向同一个内存地址，无论创建多少个该类对像），只要静态变量所在的类被加载进JVM虚拟机，这个静态变量就会被分配空间，就可以使用了。<em>Tips：不能在方法体中定义静态变量。</em></li>
<li>static方法是类方法，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，可能该类的对象还没有被创建。static方法一个很重要的用途是实现单例设计模式，单例模式只能有一个实例，为了实现这一功能，必须隐藏该类的构造器（private），只对外暴露一个创建对象的方法，且声明为static。</li>
<li>static代码块是类中独立于成员变量和成员函数的代码块，JVM在加载类是会先加载静态代码块，且只会加载一次。</li>
<li>static内部类是呗声明为static的内部类，他可以不依赖于外部类实例而被实例化，但只能访问外部类的静态成员和变量（包括私有类型）。</li>
</ol>
<ul>
<li><p>变量有四种：实例变量、局部变量、类变量和常量；</p>
</li>
<li><p>从java7开始，switch开始支持String类型，其实依旧是int类型值的匹配，原理是调用case后面的String对象的hashCode（）方法，得到一个int类型的的hash值，然后用这个hash值标记这个case值，当匹配时，先调用这个字符串的hashCode（）方法，得到hash值，去匹配所有case，如有一个匹配成功则再调用字符串的String。equals（）方法进行匹配。如果case后面的语句中不含break，则会执行剩下的所有语句，无论下面的case值匹不匹配（包括default情况）。</p>
</li>
<li><p>volatile是一个类型修饰符，被volatile类型定义的变量，在每次使用它时都是直接从对应的内存中提取，而不会使用该对象的缓存（有事为了提高程序的运行效率，编译器会把经常访问的变量缓存起来，但再多线程编程时，变量的值可能会因为别的线程而改变了），但不能代替sychronized，且会降低程序的执行效率，所以，尽量不要使用volatile关键字；</p>
</li>
<li><p>strctfp关键字指的是精确浮点，用来确保浮点运算的准确行。当一个类被strctfp修饰时，所有方法都会自动被strctfp自动修饰。</p>
</li>
<li><p>java语言提供8种原始的数据类型（byte，short，int，long，float，double，boolean，char），这些基本类型的变量在声明之后就会立即在栈上被分配内存空间，其他的类型均为引用类型，这类变量在声明时不会被分配内存空间，只是存储了一个内存地址而已。</p>
</li>
<li><p>原始数据类型在传递参数时是值传递，而封装类型是按引用传递的；</p>
</li>
<li><p>java语言中，默认声明的小数是double类型的，因此在对float类型的变量进行初始化时需要进行类型转换（f = 1.0f 或者 float f = （float）1.0），类似的是默认声明的整型数字是int类型，因此在给long类型的变量直接赋值时，需要显式转换，long l = 1234567890L；</p>
</li>
<li><p>创建一个不可变类需要遵循以下四条基本原则：（1）类中的所有成员变量均被private修饰；（2）类中没有写或者修改成员变量的方法，只提供构造函数，一次生成，永不改变；（3）如果一个类成员不是不可变量，那么在成员初始化或者使用个体get（）方法获取该成员变量时，需要通过clone（）方法来确保类的不可变性；（4）如有必要，，可覆盖Object类中的equals（）方法和hashcode（）方法，在equals（）方法判断为相等的两个对象的hashcode（）方法的返回值也相等，这可以保证这些对象能够被正确的防盗Hashmap或者HashSet中去；切不可滥用该种模式，以免发生一些无法预料的问题；</p>
</li>
</ul>
<h4 id="值传递与引用传递的区别"><a href="#值传递与引用传递的区别" class="headerlink" title="值传递与引用传递的区别"></a>值传递与引用传递的区别</h4><p>java处理8种基本的数据类型用的是值传递，其它类型都用的是引用传递，包括8种基本数据类型的的包装类（一旦赋值即为不可变量）；</p>
<ol>
<li>值传递：在方法的调用中，实参（add(1,2)）会把他的值传递给形参(void add(int a,int b))，形参只是用实参初始化的一个临时的存储单元，因此形参与实参虽然有相同的值，但却有着不同的存储单元，<em>因此对形参的改变不会影响实参的传递</em>；</li>
<li>引用传递：如果在方法的调用中传递的是对象（也可以看作是对象的内存地址），这时形参与实参的对象指向同一块存储单元，<em>因此对形参的修改就会影响到实参的值</em>；</li>
</ol>
<figure class="highlight plain"><figcaption><span>add (StringBuffer ss1,StringBuffer ss2)&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ss1.append(&quot;world&quot;);</span><br><span class="line">ss2 = ss1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(String args[])&#123;</span><br><span class="line">Stringbuffer s1 = new Stringbuffer(&quot;Hello&quot;);</span><br><span class="line">Stringbuffer s1 = new Stringbuffer(&quot;Hello&quot;);&#125;</span><br><span class="line">add(s1,s2)</span><br><span class="line">system.ou.println(s1);</span><br><span class="line">system.ou.println(s2);</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：Hello World；Hello；<br>因为在此程序当中，当s1和s2作为实参传递到add中时，虽然是“引用传递”，但是有一要点：“引用也是按值传递的”，他们传递的是s1和s2的两个地址的<em>值</em>，在调用方法append（）时，会修改ss1所指向的字符串的值（指向“Hello World的地址”）因此会修改调用者的s1的值，但在执行ss2 = ss1时，只修改ss2的值而对s2并无影响，因此s2的值在调用前后不变,过程如下图：</p>
<p><img src="http://wx4.sinaimg.cn/large/ace57effgy1fuih40lwh9j20rx0gc1kx.jpg" alt="不变量的引用传递"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">第一个例子：基本类型</span><br><span class="line">void foo(int value) &#123;</span><br><span class="line">    value = 100;</span><br><span class="line">&#125;</span><br><span class="line">foo(num); // num 没有被改变</span><br><span class="line"></span><br><span class="line">第二个例子：没有提供改变自身方法的引用类型</span><br><span class="line">void foo(String text) &#123;</span><br><span class="line">    text = &quot;windows&quot;;</span><br><span class="line">&#125;</span><br><span class="line">foo(str); // str 也没有被改变</span><br><span class="line"></span><br><span class="line">第三个例子：提供了改变自身方法的引用类型</span><br><span class="line">StringBuilder sb = new StringBuilder(&quot;iphone&quot;);</span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder.append(&quot;4&quot;);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。</span><br><span class="line"></span><br><span class="line">第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</span><br><span class="line">StringBuilder sb = new StringBuilder(&quot;iphone&quot;);</span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder = new StringBuilder(&quot;ipad&quot;);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。只要使用new关键字就会在堆中创建一个新的对象</span><br></pre></td></tr></table></figure>
<ul>
<li><p>强制类型转换时，需注意：java在涉及byte，short和char类型运算时，首先会把这些类型的变量值强制转换为int类型，然后对int类型的值进行计算，最后得到的也是int类型的结果，例如语句short s1 = 1；s1 = s1 + 1；由于在运行时首先会将s1转换为int类型，因此s1 + 1的结果为int类型，这样编译器会报错，所以正确的写法应该是short s1 = 1；s1 = （short）（s1 + 1）；但是如果使用+=就可以通过编译（+=为java语言中规定的运算法，java编译器会对其特殊处理）；</p>
</li>
<li><p>在java语言中，默认使用Unicode编码，即每个字符占两个字节。</p>
</li>
</ul>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">Show TOC</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">Hide TOC</button>
  <div class="random-toc">
    <h2>Table of Content</h2>
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#重载和覆盖的区别："><span class="toc-text">重载和覆盖的区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#小结"><span class="toc-text">小结:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口与抽象类："><span class="toc-text">接口与抽象类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么时候使用抽象类和接口？"><span class="toc-text">什么时候使用抽象类和接口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象的主要特征包括抽象、继承、封装和多态："><span class="toc-text">面向对象的主要特征包括抽象、继承、封装和多态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承有如下特点："><span class="toc-text">继承有如下特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多态的实现机制："><span class="toc-text">多态的实现机制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#break、continue以及return的区别："><span class="toc-text">break、continue以及return的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final、finally和finalize的区别："><span class="toc-text">final、finally和finalize的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Static关键字的作用"><span class="toc-text">Static关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#值传递与引用传递的区别"><span class="toc-text">值传递与引用传递的区别</span></a></li></ol>
  </div>
</div>

  
<nav id="pagination">
  

  

  
    <a href="/2018/08/12/Linux常用命令/" class="next">Next post Linux常用命令 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Alan Haze using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/volvo.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/AlanHaze">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://twitter.com/alanhaze2">
        
          <i class="icon iconfont twitter">&#xe600;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://www.zhihu.com/people/tang-dun/activities">
        
          <i class="icon iconfont zhihu">&#xe60b;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://plus.google.com/u/0/107452576753639843741">
        
          <i class="icon iconfont google-plus">&#xe603;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["slideLeft2","slideRight2","flash2"],"timer":true,"delay":5000,"shuffle":true,"count":28};
var unsplashConfig = {"blur":false,"gravity":"north"};
// is show background images
var turnoffBackgroundImage = false;



  turnoffBackgroundImage = true;


var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

