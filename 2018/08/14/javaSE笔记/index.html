






<!doctype html>
<html lang="">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Alan Haze">
  
  
  
  
    <meta name="description" content="java程序的初始化一般遵循3个原则（优先级依次递减）：1. 静态对象（变量）优先于非静态对象（变量）初始化。2. 父类优先于子类进行初始化。3. 按照成员变量的定义顺序进行初始化。

只有public、abstract或者final可以用来修饰类。


重载和覆盖的区别：
重载是一个类里面,函数名相同但参数列表不同的函数，不能通过方法的访问权限、返回值类型和抛出异常类型来进行重载。
而覆盖...">
  
  <title>JavaSE笔记 [ AlanHaze's blog ]</title>
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
  
    <div class="item next">
      <a href="/2018/08/12/Linux常用命令/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        Linux常用命令
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/volvo.jpg"/>
          <div id="homelink">AlanHaze's blog</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">Home</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">Archives</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">Tags</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">Categories</a>
            
          </li>
        
          
            <li>
          
            <a href="https://github.com/stiekel/hexo-theme-random">About</a>
            
          </li>
        
          
            <li>
          
            <a href="https://github.com/AlanHaze">Github</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  <article id="post">
    <h1>JavaSE笔记</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">Created at 2018-08-14</span>
      
        <span id = "post-title-updated">Updated at 2018-09-11</span>
      
      
      
      <span id = "post-title-tags">
      Tag
      
      
        
        
        <a href="/tags/JavaSE/">JavaSE</a>
      
      </span>
      
    </p>
    
    <ul>
<li><p>java程序的初始化一般遵循3个原则（优先级依次递减）：1. 静态对象（变量）优先于非静态对象（变量）初始化。2. 父类优先于子类进行初始化。3. 按照成员变量的定义顺序进行初始化。</p>
</li>
<li><p>只有public、abstract或者final可以用来修饰类。</p>
</li>
</ul>
<h4 id="重载和覆盖的区别："><a href="#重载和覆盖的区别：" class="headerlink" title="重载和覆盖的区别："></a>重载和覆盖的区别：</h4><ol>
<li>重载是一个类里面,函数名相同但参数列表不同的函数，不能通过方法的访问权限、返回值类型和抛出异常类型来进行重载。</li>
<li>而覆盖是子类类重写了父类的函数，且需要有相同的函数名、参数列表、返回值类型、抛出的异常类型都需要相同；如在继承中，父类定义了一个private方法，而子类也定义了一个同名函数，那这是一个新的方法，而不是重载；<h5 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h5><ol>
<li>覆盖是子类和父类之间的关系，属垂直关系；重载是一个类中方法之间的关系，属水平关系；</li>
<li>覆盖只能由一个方法或只对一个方法产生关系，而重载是多个方法之间的关系；</li>
<li>覆盖要求参数列表相同，重载则是要求不同；</li>
<li>覆盖关系中，调用方法体是根据对象的类型来决定，而重载关系是根据调用时的实参表与形参表来选择方法体的；</li>
</ol>
</li>
</ol>
<ul>
<li>在父类没有提供无参数的构造函数时，子类的构造函数必须显式的调用父类构造函数。如果父类提供了无参数构造器则可以不显式的调用父类的构造函数，在这种情况下编译器会默认调用父类提供的无参数构造函数。当有父类时，在实例化对象时会先执行父类的构造函数，然后再执行子类的构造函数。</li>
</ul>
<h4 id="接口与抽象类："><a href="#接口与抽象类：" class="headerlink" title="接口与抽象类："></a>接口与抽象类：</h4><p>抽象类：</p>
<ol>
<li>只要包含一个抽象方法的类就必须声明为抽象类，被声明的抽象方法不能包含方法体；</li>
<li>实现类实现时，必须包含相同的或者更低的访问级别（public—&gt;protected—&gt;private）；</li>
<li>抽象类在使用过程中不能被实例化，但是可以创建一个对象使其指向具体子类的一个实例；</li>
<li>抽象类的子类为父类的所有抽象方法提供具体实现，否则他们也是抽象类；</li>
<li>抽象类可以包含部分方法的实现；</li>
</ol>
<p>接口：</p>
<ol>
<li>接口是特殊的抽象类；</li>
<li>接口中的所有方法都是抽象的；</li>
<li>接口中的成员变量都是static final类型；</li>
</ol>
<p>共同点：</p>
<ol>
<li>都不能被实例化；</li>
<li>接口的实现类或者抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化；</li>
</ol>
<p>不同点：</p>
<ol>
<li>接口只能定义方法，不能提供方法的实现，只有实现类才能实现接口中的方法；抽象类中可以有定义可以有实现；</li>
<li>接口需要实现（implements），抽象类只能被继承（extends）；</li>
<li>接口强调特定功能的实现，设计理念为“has-a”关系；抽象类强调所属关系，设计理念为“is-a”关系；</li>
<li>接口中定义的成员变量默认为<em>public static final</em>，<em>只能够有静态的不能被修改的数据成员，且必须给其赋值</em>，其所有<em>成员方法都是public abstract的</em>，而且只能够被<em>这两个关键字</em>修饰；抽象类可以有<em>自己的数据成员变量</em>，也可以有非抽象的成员方法，而且抽象类中的<em>成员变量默认为default（本包可见）</em>，当然也可以被定义为private、protected和public，这些成员变量可以在子类中被重新定义，也可以被重新赋值，抽象类中的抽象方法（必须有abstract修饰）不能用private、static、synchronized、native（Native Method就是一个java调用非java代码的接口）等访问修饰符，同时方法只能以分号结尾，且不能带花括号；</li>
<li>接口被用于实现比较常用的功能，便于日后维护或者添加删除方法；抽象类更倾向与充当公共类的角色，不适用于日后对里面的代码进行修改；</li>
</ol>
<h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><ol>
<li>接口时一种特殊的抽象类，使用接口完全有可能实现与抽象类相同的操作；</li>
<li>当子类和父类之间存在有逻辑上的层次结构时，使用抽象类；</li>
<li>不同类之间，定义不同类之间的通信规则、希望支持两个差别较大或者更多对象之间特定的交互行为时，使用接口；</li>
<li>接口可以继承接口，抽象类可以实现接口，抽象类也可以继承具体类，抽象类可以有main方法（接口不能）。</li>
</ol>
<h4 id="什么时候使用抽象类和接口？"><a href="#什么时候使用抽象类和接口？" class="headerlink" title="什么时候使用抽象类和接口？"></a>什么时候使用抽象类和接口？</h4><ol>
<li>如果拥有一些方法并且想让它们中的一些有默认实现，使用抽象类。</li>
<li>如果想实现多重继承，只能使用接口。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ol>
<ul>
<li><p>如一个接口中没有任何方法，就叫做标识接口，标识接口对于实现它的类没有任何语义上的要求，仅作标识用，java中已存在的标识接口有Cloneable和Serializable等，在使用时可以使用instanceof来判断该实例对象是否实现了一个给定的接口。</p>
</li>
<li><p>为了解决C/C++中指针带来的不便，java取消了指针的概念，但这只是在java语言中没有明确提供指针的概念和用法，而实质上每次使用new语句返回的都是一个指针的引用，只是无需开发人员关心而已。</p>
</li>
<li><p>Object类中提供一个clone（）方法，该方法可返回一个对象的复制而非该对象的引用，且存在深复制与浅复制之分。</p>
</li>
<li><p>反射机制所能提供的功能主要有：获取一个类的所有成员变量和方法；在运行时动态的创建类的对象；在运行时调用对象的方法；获取class类的方法有三种（1）class.forname(“类的路径”)（2）类名.class（3）该类实例.getClass()。所以创建类有四种方法：new语句；反射机制；clone（）方法；反序列化；</p>
</li>
</ul>
<h4 id="面向对象的主要特征包括抽象、继承、封装和多态："><a href="#面向对象的主要特征包括抽象、继承、封装和多态：" class="headerlink" title="面向对象的主要特征包括抽象、继承、封装和多态："></a>面向对象的主要特征包括抽象、继承、封装和多态：</h4><ol>
<li>抽象：抽象就是忽略一个主题与当前目标无关的方面，主要关注与当前目标有关的方面。抽象包括两个方面：一个是过程抽象；一个是数据抽象。</li>
<li>继承：对象的一个新类可以从现有的类中派生，这个过程成为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始的类成为新类的基类（父类），派生类可以从它的父类中继承方法和实例变量，并且子类可以修改或增加新的方法使之更适合特殊的需要。</li>
<li>封装：封装是指将客观事物抽象成类，每个类对自身的数据和方法实行保护。类可以可以把自己的数据和方法只让可信任的类和对象进行操作，对不可信的进行信息隐藏。</li>
<li>多态：多态是指允许不同类的对象对同一消息做出响应。多态性语言具有灵活、抽象、行为共享、代码共享等优势，很好的解决了应用程序函数同名的问题。</li>
</ol>
<h4 id="继承有如下特点："><a href="#继承有如下特点：" class="headerlink" title="继承有如下特点："></a>继承有如下特点：</h4><ol>
<li>java不支持多继承，但可以通过实现多个接口来达到多重继承的目的。</li>
<li>子类只能继承父类的非私有（public和protected）成员变量和方法。</li>
<li>当子类中定义的成员变量和父类中定义的成员变量同名时，子类中的成员变量会覆盖父类的成员变量，而不会继承。</li>
<li>当子类中的方法和父类中的方法有相同的函数签名（相同的方法名，相同的参数列表）时，子类会覆盖父类的方法，而不会继承。</li>
</ol>
<p><em>Tips：</em></p>
<ol>
<li>除非两个类是“is-a”关系否则不要轻易使用继承，不要单纯为了实现代码的重用而使用继承，因为过多的使用继承会破坏代码的可维护性，当父类被修改时，会影响到所有继承自它的子类，从而增加程序的维护难度和成本。</li>
<li>不要仅仅为了实现多态而使用继承，如果类之间没有“is-a”关系可以考虑使用接口和组合来达到相同的目的，还可拥有更好的扩展性。能使用组合就尽量不要使用继承！</li>
</ol>
<h4 id="多态的实现机制："><a href="#多态的实现机制：" class="headerlink" title="多态的实现机制："></a>多态的实现机制：</h4><ol>
<li>方法的重载：拥有不同参数列表的重载方法，是在编译时确定到底采用那个方法，是一种编译时多态。</li>
<li>方法的覆盖：子类覆盖父类的方法，因此同样的方法就有了不同的表现形式，父类的引用变量不仅可以指向父类的实例对象，还能指向子类的实例对象，同样，接口的引用变量也能指向实现类的实例对象，而程序调用的方法在运行期间才动态绑定，就是应用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法，由于只有在运行时才能确定调用哪个方法，所以通过方法覆盖实现的多态也可以被称为运行时多态。</li>
</ol>
<p>Tips：只有类中的方法才有多态概念，类中的成员变量是没有多态的概念的。成员变量的取值并不取决于创建对象的类型，而是取决于所定义变量的类型。</p>
<ul>
<li><p>内部类分四种：静态内部类（satatic inner class）（不能访问外部类普通成员变量）、成员内部类（member inner class）、局部内部类（local inner class）、匿名内部类（anonymous inner class）；所有非静态内部类不能有静态成员；</p>
</li>
<li><p>如何获取父类类名：用super.getClass().getName()获取的依旧是子类的类名，因为最终调用的是Object类中的getClass()方法，而此方法的释义是返回此Object的运行时的类名，所以应该使用this.getSuperclass().getname()方法；</p>
</li>
<li><p>this.变量名代表所在类中的成员变量；当子类和父类的方法和成员变量同名时会覆盖父类中的方法和成员变量，只能通过super关键字访问父类中的方法和成员变量；</p>
</li>
<li><p>当子类构造函数需要显式调用父类构造函数时，super（）必须作为构造函数中的第一条语句；</p>
</li>
<li><p>标识符不能以数字开头、不能有空格、不能使用关键字和保留字、不能包含“ * ”； </p>
</li>
</ul>
<h4 id="break、continue以及return的区别："><a href="#break、continue以及return的区别：" class="headerlink" title="break、continue以及return的区别："></a>break、continue以及return的区别：</h4><ol>
<li>break用于强行跳出当前循环，不再执行剩余代码，跳出循环体执行下面的语句；</li>
<li>continue用于停止当次循环，之后的语句不再执行，回到循环起始处进入下一次循环操作。一般用于跳过循环中的一部分语句；</li>
<li>return语句是一个跳转语句，表示从一个方法返回（一个值或者其他复杂类型），可以使程序返回到调用该方法的地方。当main方法中有return时，程序返回到java运行系统；</li>
</ol>
<ul>
<li>可以在循环体外定义一个标签（标签名 + “:”），使用break关键字后可以跳到该处继续执行程序；</li>
</ul>
<h4 id="final、finally和finalize的区别："><a href="#final、finally和finalize的区别：" class="headerlink" title="final、finally和finalize的区别："></a>final、finally和finalize的区别：</h4><ol>
<li><p>final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖和类不可被继承。</p>
<ol>
<li>final属性：被其修饰的变量不可变。由于不可变有两重含义：一是引用不可变（指向初始时的那个对象，对象内容不关心）；二是对象不可变（对象内容不可变），被final修饰的变量是引用不可变（如final StringBuffer依旧可以append），但在声明该变量时必须初始化（不能在静态初始化块中初始化。static修饰的就可以，但其就不能在非静态初始块中初始化）。</li>
<li>final方法：当一个方法声明为final时，该方法不可被任何子类重写，但子类可以使用该方法。</li>
<li>final类：当一个类被声明为final时，该类不可被继承，所有方法不得被重写（但其成员变量并非final，需自行添加final进行修饰）。Tips：一个类不可既被声明为abstract，又被声明为final。</li>
</ol>
</li>
<li><p>finally是异常处理的一部分，通常用在try/catch语句中，表示finally语句块中的语句一定会执行。</p>
</li>
<li>finalize是Object类中的一个方法，在垃圾回收器执行时会调用被回收对像的finalize（）方法，可以覆盖此方法来实现对其他资源的回收。Tips：一旦垃圾回收器准备好释放对像占用的空间，将首先调用其finalize（）方法，并在下一次垃圾回收器动作发生时，才会真正回收该对象的内存。</li>
</ol>
<ul>
<li>作用：是用于对程序进行调试的，对于执行结构的判断，而不是对于业务流程的判断。（相当于一个if ()语句，如果满足断言的执行程序，如果不满足则抛错误），只适用复杂的调式过程。</li>
</ul>
<h4 id="Static关键字的作用"><a href="#Static关键字的作用" class="headerlink" title="Static关键字的作用"></a>Static关键字的作用</h4><p>主要有两个作用，第一：为模特定数据类型或对象分配单一的存储空间，与创建对象的个数无关。第二：实现某个方法和属性与类而不是与对象关联在一起，从而可以在不创建对象的情况下调用方法。static主要有4种使用情况：成员变量、成员方法、代码块和内部类。</p>
<ol>
<li>static修饰的成员变量属于类，在内存中只有一个复制（所有实例都指向同一个内存地址，无论创建多少个该类对像），只要静态变量所在的类被加载进JVM虚拟机，这个静态变量就会被分配空间，就可以使用了。<em>Tips：不能在方法体中定义静态变量。</em></li>
<li>static方法是类方法，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，可能该类的对象还没有被创建。static方法一个很重要的用途是实现单例设计模式，单例模式只能有一个实例，为了实现这一功能，必须隐藏该类的构造器（private），只对外暴露一个创建对象的方法，且声明为static。</li>
<li>static代码块是类中独立于成员变量和成员函数的代码块，JVM在加载类是会先加载静态代码块，且只会加载一次。</li>
<li>static内部类是呗声明为static的内部类，他可以不依赖于外部类实例而被实例化，但只能访问外部类的静态成员和变量（包括私有类型）。</li>
</ol>
<ul>
<li><p>变量有四种：实例变量、局部变量、类变量和常量；</p>
</li>
<li><p>从java7开始，switch开始支持String类型，其实依旧是int类型值的匹配，原理是调用case后面的String对象的hashCode（）方法，得到一个int类型的的hash值，然后用这个hash值标记这个case值，当匹配时，先调用这个字符串的hashCode（）方法，得到hash值，去匹配所有case，如有一个匹配成功则再调用字符串的String。equals（）方法进行匹配。如果case后面的语句中不含break，则会执行剩下的所有语句，无论下面的case值匹不匹配（包括default情况）。</p>
</li>
<li><p>volatile是一个类型修饰符，被volatile类型定义的变量，在每次使用它时都是直接从对应的内存中提取，而不会使用该对象的缓存（有事为了提高程序的运行效率，编译器会把经常访问的变量缓存起来，但再多线程编程时，变量的值可能会因为别的线程而改变了），但不能代替sychronized，且会降低程序的执行效率，所以，尽量不要使用volatile关键字；</p>
</li>
<li><p>strctfp关键字指的是精确浮点，用来确保浮点运算的准确行。当一个类被strctfp修饰时，所有方法都会自动被strctfp自动修饰。</p>
</li>
<li><p>java语言提供8种原始的数据类型（byte，short，int，long，float，double，boolean，char），这些基本类型的变量在声明之后就会立即在栈上被分配内存空间，其他的类型均为引用类型，这类变量在声明时不会被分配内存空间，只是存储了一个内存地址而已。</p>
</li>
<li><p>原始数据类型在传递参数时是值传递，而封装类型是按引用传递的；</p>
</li>
<li><p>java语言中，默认声明的小数是double类型的，因此在对float类型的变量进行初始化时需要进行类型转换（f = 1.0f 或者 float f = （float）1.0），类似的是默认声明的整型数字是int类型，因此在给long类型的变量直接赋值时，需要显式转换，long l = 1234567890L；</p>
</li>
<li><p>创建一个不可变类需要遵循以下四条基本原则：（1）类中的所有成员变量均被private修饰；（2）类中没有写或者修改成员变量的方法，只提供构造函数，一次生成，永不改变；（3）如果一个类成员不是不可变量，那么在成员初始化或者使用个体get（）方法获取该成员变量时，需要通过clone（）方法来确保类的不可变性；（4）如有必要，，可覆盖Object类中的equals（）方法和hashcode（）方法，在equals（）方法判断为相等的两个对象的hashcode（）方法的返回值也相等，这可以保证这些对象能够被正确的放到Hashmap或者HashSet中去；切不可滥用该种模式，以免发生一些无法预料的问题；</p>
</li>
</ul>
<h4 id="值传递与引用传递的区别"><a href="#值传递与引用传递的区别" class="headerlink" title="值传递与引用传递的区别"></a>值传递与引用传递的区别</h4><p>java处理8种基本的数据类型用的是值传递，其它类型都用的是引用传递，包括8种基本数据类型的的包装类（一旦赋值即为不可变量）；</p>
<ol>
<li>值传递：在方法的调用中，实参（add(1,2)）会把他的值传递给形参(void add(int a,int b))，形参只是用实参初始化的一个临时的存储单元，因此形参与实参虽然有相同的值，但却有着不同的存储单元，<em>因此对形参的改变不会影响实参的传递</em>；</li>
<li>引用传递：如果在方法的调用中传递的是对象（也可以看作是对象的内存地址），这时形参与实参的对象指向同一块存储单元，<em>因此对形参的修改就会影响到实参的值</em>；</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void add (StringBuffer ss1,StringBuffer ss2)&#123;</span><br><span class="line">ss1.append(<span class="string">"world"</span>);</span><br><span class="line">ss2 = ss1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(String args[])&#123;</span><br><span class="line">Stringbuffer s1 = new Stringbuffer(<span class="string">"Hello"</span>);</span><br><span class="line">Stringbuffer s1 = new Stringbuffer(<span class="string">"Hello"</span>);&#125;</span><br><span class="line">add(s1,s2)</span><br><span class="line">system.ou.println(s1);</span><br><span class="line">system.ou.println(s2);</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：Hello World；Hello；<br>因为在此程序当中，当s1和s2作为实参传递到add中时，虽然是“引用传递”，但是有一要点：“引用也是按值传递的”，他们传递的是s1和s2的两个地址的<em>值</em>，在调用方法append（）时，会修改ss1所指向的字符串的值（指向“Hello World的地址”）因此会修改调用者的s1的值，但在执行ss2 = ss1时，只修改ss2的值而对s2并无影响，因此s2的值在调用前后不变,过程如下图：</p>
<p><img src="http://wx4.sinaimg.cn/large/ace57effgy1fuih40lwh9j20rx0gc1kx.jpg" alt="不变量的引用传递"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//第一个例子：基本类型</span><br><span class="line">void foo(int value) &#123;</span><br><span class="line">    value = 100;</span><br><span class="line">&#125;</span><br><span class="line">foo(num); // num 没有被改变</span><br><span class="line"></span><br><span class="line">//第二个例子：没有提供改变自身方法的引用类型</span><br><span class="line">void foo(String text) &#123;</span><br><span class="line">    text = <span class="string">"windows"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(str); // str 也没有被改变</span><br><span class="line"></span><br><span class="line">//第三个例子：提供了改变自身方法的引用类型</span><br><span class="line">StringBuilder sb = new StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder.append(<span class="string">"4"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); // sb 被改变了，变成了<span class="string">"iphone4"</span>。</span><br><span class="line"></span><br><span class="line">//第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</span><br><span class="line">StringBuilder sb = new StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder = new StringBuilder(<span class="string">"ipad"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); // sb 没有被改变，还是 <span class="string">"iphone"</span>。只要使用new关键字就会在堆中创建一个新的对象</span><br></pre></td></tr></table></figure>
<ul>
<li><p>强制类型转换时，需注意：java在涉及byte，short和char类型运算时，首先会把这些类型的变量值强制转换为int类型，然后对int类型的值进行计算，最后得到的也是int类型的结果，例如语句short s1 = 1；s1 = s1 + 1；由于在运行时首先会将s1转换为int类型，因此s1 + 1的结果为int类型，这样编译器会报错，所以正确的写法应该是short s1 = 1；s1 = （short）（s1 + 1）；但是如果使用+=就可以通过编译（+=为java语言中规定的运算法，java编译器会对其特殊处理）；</p>
</li>
<li><p>在java语言中，默认使用Unicode编码，即每个字符占两个字节。</p>
</li>
<li><p>new String（“abc”）语句会创建一或者两个对象：如果常量池中有“abc”，那么只创建一个对象，如果没有，则会创建两个对象；</p>
</li>
<li><p>“ == ”、equals和hashcode的区别：</p>
</li>
</ul>
<ol>
<li>“ == ”运算符是用来比较值是否相等。对于基本数据类型，可以直接使用“ == ”来比较其对应的值是否相等，而对于对象（引用类型）来说是比较的是内存地址而非对象中的内容；</li>
<li>equals是Object类中提供的方法，而其实现体是直接使用“ == ”来比较两个对象，所以如需在自己的类中使用该方法需覆盖重写该方法来决定在什么情况下即可认为两个对象的内容是相等的；</li>
<li>hashcode（）同样是从Object中的方法，也是用来比较两个对象是否相等，若不重写该方法，便会将对象在内存中的地址转换为int值并做比较再返回，任何对象的hashcode（）方法都是不相等的；这个方法一般用户不会去调用它，例如在hashmap中，由于key是不可重复的（equals和hashcode中有一个不等就可以），它在判断时就用到了hashcode()方法。所以hashcode（）方法相当与对象的编码，类似于文件的MD5值，他与equals（）方法区别就是返回的事int类型，不直观。<em>需要注意的是</em>在覆盖equals()方法时需要同时覆盖hashcode()方法，否则会违反Object.code的通用规定，从而导致无法与所有基于散列值（hash）的集合类（hashmap，hashset，hashtable）结合在一起正常运行。</li>
</ol>
<ul>
<li><p>数组是一个单独的类型；</p>
</li>
<li><p>Set是采用equals（）方法判断两个对象是否相同；</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestSet &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Set books = new HashSet();  </span><br><span class="line">        books.add(new String(<span class="string">"张大三"</span>));  </span><br><span class="line">        System.out.println(books);//打印结果：[张大三]  </span><br><span class="line">        //再次添加一个字符串对象  </span><br><span class="line">        //因为这连个字符串对象通过equals方法比较相等，所以添加失败，返回<span class="literal">false</span>  </span><br><span class="line">        boolean result = books.add(new String(<span class="string">"张大三"</span>));  </span><br><span class="line">        //下面看到集合中只有一个元素  </span><br><span class="line">        System.out.println(result);  </span><br><span class="line">        System.out.println(books);//打印结果：[张大三]  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="String、StringBuffer、StringBuilder和StringTokenized的区别"><a href="#String、StringBuffer、StringBuilder和StringTokenized的区别" class="headerlink" title="String、StringBuffer、StringBuilder和StringTokenized的区别"></a>String、StringBuffer、StringBuilder和StringTokenized的区别</h4><p>java语言中有四个类可以对字符串进行操作，他们分别是Character、String、StringBuffer和StringTokenized，其中Character是用于单个字符串的操作，String用于字符串的操作（不可变类），StringBuffer也是用于字符串操作，但是属于可变类。</p>
<ol>
<li>当一个字符串会被<em>经常修改</em>时，使用StringBuffer，如做常量就使用String。如要修改一个修改字符串原理如下：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">s += <span class="string">"World"</span>;</span><br></pre></td></tr></table></figure>
<p>以上代码等价于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = new StringBuffer(s);</span><br><span class="line">s.append(<span class="string">"World"</span>);</span><br><span class="line">s = sb.toString();//可见影响效率</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>StringBuilder不是线程安全的，如果只在单线程中使用，StringBuilder的效率会高一些；如当前有多个线程访问时，最好使用线程安全的StringBuffer。一般来说，如果要操作的的字符串数据量比较小，应优先使用String类；如要在单线程下操作大量数据应优先使用StringBuilder类；在多线程环境下操作大量数据应考虑使用StringBuffer类；</li>
<li>StringTokenizer类可以讲字符串进行分割，默认是以空格作为分割符，分割成单一的单词:对象名.hasMoreToken()；</li>
</ol>
<ul>
<li><p>java语言中，数组拥有自己的属性（例如length属性），也有方法可以被调用（例如clone方法）。由于对象的特点是封装了一些数据，同时提供了一些属性和方法，从这个角度来说，数组是对象。每个数组都有其对应的类型（例如int类型数组,int类型二维数组,String类型数组）；</p>
</li>
<li><p>数组提供了length属性来获取数组的长度；String提供了length（）方法来计算字符串的长度；</p>
</li>
<li><p>size（）方法是查看泛型集合中有多少元素的方法；</p>
</li>
<li><p>try-catch-finally语句中如有return的情况，finally代码块会在return之前执行。因为finally块的作用就是无论发生什么情况都会执行的代码，由于程序执行return就意味着结束当前方法并跳出这个方法体，因此任何语句的执行都要在return之前呗执行（除非碰到exit方法）。此外，如果try-catch或者catch-finall中都有return，那么finally中的return会覆盖别处的return语句，最终返回到调用者那里的是finally中的return的值。<br><em>Tips：</em><br>由于在一个方法内部定义的变量存储在栈中，当这个方法结束后，其对应的栈就会被回收，此时在其方法体中定义的变量将不复存在，<em>因此执行return时会首先将返回值存储在一个指定位置，其次再去执行finally块，然后再返回。</em>因此，对于基本类型的数据，在finally块中改变return的值对返回值没有任何影响，而对引用类型的数据会有影响。</p>
</li>
</ul>
<h4 id="java异常处理机制"><a href="#java异常处理机制" class="headerlink" title="java异常处理机制"></a>java异常处理机制</h4><p>java语言把异常当作对象来处理，并定义了一个类（Throwable类）作为所有异常的父类，异常又分为两类，Error（错误）和Exception（异常）。</p>
<ol>
<li>Error便是程序出现了非常严重的错误，JVM会将程序终止。一个正确的程序应不存在Error。</li>
<li>Exception表示可以修复的异常，是编译器可以捕捉到的，它包含两种类型：检查异常（checked exception）和运行时异常（runtime exception）：<ol>
<li>检查异常：所有继承于Exception并且不是运行时异常的都是检查异常，可以用try-catch来捕获并处理异常（如连接数据库失败可重新连接解决）；</li>
<li>运行时异常（不必处理）：在java中，最常见的运行时异常包括NullPointException（空指针异常）、ClassCastException(类型转换异常)、ArrayIndexOutOfBoundException(数组越界异常)、ArrayStoreException(数组存储异常)、BufferOverflowException（缓存溢出异常）、ArithmeticException(算数异常)。<em>出现异常后，系统会一直往上层抛出，直到遇到处理代码为之，若没有处理代码，则抛到最上层；如果是多线程就用Thread。run（）方法抛出，线程退出；如果是单线程，就用mian（）方法抛出，整个程序退出。</em></li>
</ol>
</li>
</ol>
<h4 id="throw与throws的比较"><a href="#throw与throws的比较" class="headerlink" title="throw与throws的比较"></a>throw与throws的比较</h4><ol>
<li>throws出现在方法函数头；而throw出现在函数体。</li>
<li>throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。</li>
<li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</li>
</ol>
<ul>
<li><p>java中，输入和输出都被称为抽象的流，流可以被看作一组有序的字节集合，即数据在两设备之间传输。流的本质是数据的传输，根据处理数据类型的不同，流可以被分为两大类，<em>字节流和字符流</em>，字节流以字节（8bit）为单位，包含两个抽象类：输入流（InputStream）和输出流(OutputStrseam);字符流以字符（16bit）为单位，根据码表映射字符，一次可读多个字节，包含两个抽象类：Read（输入流）和Write（输出流）。<em>二者最主要的区别为：</em>字节流在处理输入输出时不会用到缓存，而字符流用到了缓存。</p>
</li>
<li><p>java IO类在设计时采用了Decorator（装饰者）设计模式。</p>
</li>
<li><p>JDK1.4的java.nio包中引入了新的Java-IO类库，目的是提高速度，实际上，旧的IO包也已经使用nio重新实现过，以便充分利用这种速度提高。速度的提高在文件IO和网络IO。速度的提高来自于所使用的结构更接近于操作系统执行IO的方式：通道和缓冲器。旧IO中有三个类被修改了，分别是FileInputStream、FileOutputStream和RandomAccessFile，在处理大量并发请求时，使用NIO要比使用Socket效率高很多。</p>
</li>
<li><p>java字节码执行分两种方式：即时编译与解释编译。即时编译指的是解释器先将字节码编译成机器码，然后再执行该机器码。解释执行方式指的是解释器通过每次解释并执行一小段代码来完成java字节码程序的所有操作。通常采用的是解释执行方式。</p>
</li>
<li><p>java平台主要包含两个模块：JVM与java API（Application Program Interface，应用程序接口）；</p>
</li>
<li><p>类的加载方式分为隐式加载与显式加载两种，隐式加载指的是程序在使用new关键字等方式创建对象时，会隐式的调用类的加载器把对应的类加载到JVM中。显式加载指的是通过直接调用class.forName（）方法来把所需要的类加载到JVM中。在程序启动时，只把需要的基础类类（如基类）加载到JVM中，其他类只有在被使用到的时候才会被加载，采用这种方法，可以加快加载速度和减少内存开销，所以每一个类对应一个.class文件，这些文件可以被看成一个个可以被动态加载的单元，因此只有部分类被修改时，只需要重新编译变化的类即可。</p>
</li>
</ul>
<h4 id="类的加载步骤"><a href="#类的加载步骤" class="headerlink" title="类的加载步骤"></a>类的加载步骤</h4><ol>
<li>装载：根据查找路径找到对应的class文件，然后导入。</li>
<li>链接：链接又可分为三步：<br>1) 检查:检查待加载的class文件的正确性；<br>2) 准备：给类中的静态变量分配存储空间；<br>3) 解析：将符号引用（在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替）转换成直接引用；</li>
<li>初始化：对静态变量和静态代码执行初始化工作；</li>
</ol>
<ul>
<li><p>垃圾回收器（Garbage Collection，GC）是一个非常重要的概念，他的主要作用是回收程序中不再使用的内存。</p>
</li>
<li><p>只有当一个对象不再有任何引用指向它的时候才会成为垃圾等待GC的回收，但并不是立即回收，而是下一次垃圾回收器运行时才会被回收；</p>
</li>
<li><p>判断一个内存空间是否符合垃圾回收的标准有两个：给对象赋予了空值null，以后再没有使用过；给对象赋予了新值，重新分配了内存空间；</p>
</li>
<li><p>堆与栈是内存中存放数据的地方。基本数据类型的变量以及对象的引用变量，其内存都分配在栈上，变量除了作用域就会自动释放；引用类型的变量，其内存分配在堆中或者常量池，需要通过new等方式来创建；</p>
</li>
</ul>
<h4 id="一维数组和二维数组"><a href="#一维数组和二维数组" class="headerlink" title="一维数组和二维数组"></a>一维数组和二维数组</h4><p>在java中，数组被创建后会根据数组存放的数据类型初始化成对应的初始值（例如，int类型会被初始化为0，对象会被初始化为null）。在数组被定义时，不会给数组元素分配储存空间，因此中括号中可不指定数组长度。</p>
<ol>
<li>一维数组：<br>一维数组的声明方式为：type arrayName[]或者type[] arraryName;</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] a = new int[5]; //动态初始化：创建一个包含5个整型值的数组，默认初始化为0</span><br><span class="line">int[] a = &#123;1,2,3,4&#125;; //静态初始化：声明一个数组类型变量并初始化</span><br></pre></td></tr></table></figure>
<p>以上所谓的静态和动态是相对于程序运行是而言的，静态是在程序编译时就初始化好了的，动态初始化是在程序运行时才动态分配内存空间。两种方式唯一不一样的地方， 就是动态的初始值都是0,静态的是直接给定值了。</p>
<ol start="2">
<li>二维数组：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> arraryName[][];</span><br><span class="line"><span class="built_in">type</span>[][] arraryName;</span><br><span class="line"><span class="built_in">type</span>[] arraryName[];</span><br></pre></td></tr></table></figure>
<p>1) 需要注意的是，在声明二维数组时，其中[]必须为空。<br>2) 也可用初始化列表的方式来进行初始化，一般形式为<br><figure class="highlight plain"><figcaption><span>arraryName[][] </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">也可通过new关键字来给数组申请存储空间：type arrayName\[]\[]=\[行数]\[列数]；</span><br><span class="line">3) 二维数组第二维的长度可以不同，假如要定义一个有两行的二维数组，第一行有两列，第二行有三列，定义方法如下：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">int [][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;&#125;; //第一种方式</span><br><span class="line">int[][] a = new int[2][]; //第二种方式</span><br><span class="line">a[0] = new int []&#123;1,2&#125;;</span><br><span class="line">a[1] = new int []&#123;3,4,5&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对二维数组的访问也是通过以下方式来完成，一般形式为arryName[行号][列号],遍历方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a[][] = new int[2][];</span><br><span class="line">a[] = new int[][1,2];</span><br><span class="line">a[] = new int[][3,4,5];</span><br><span class="line"><span class="keyword">for</span>(int i = 0;i &lt; a.length;i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int j = 0;j &lt; a[i].length;j ++)&#123;</span><br><span class="line">    System.out.println(a[i][j] + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>java中的内存泄漏是指一个不再被程序使用的对象或者变量还在内存中占有存储空间；引起内存泄漏的原因主要有以下几个方面的内容：</p>
<ol>
<li><p>静态集合类：例如HashMap和Vector。这些容器为静态的，由于他们的生命周期与程序一致，那么容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。e.g</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector v = new Vector(10);</span><br><span class="line">for(int i = 0;i &lt;= 10; i ++)&#123;</span><br><span class="line">Obiect o = new Object();</span><br><span class="line">v.add(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>各种连接，如数据库连接，IO连接等。如不显式的关闭，将会造成大量的对象无法被回收，从而引起内存泄漏；</p>
</li>
<li>监听器。通常在一个应用中会用到多个监听器，但在释放对象的同时没有相应的删除监听器，这也可能导致内存泄漏；</li>
<li>变量的作用域不合理。如果一个变量定义的作用域大于其适用范围，很容易造成内存泄漏；解决办法为缩小变量的作用域或者将其使用完不再使用时设置为null，垃圾回收器就回自动回收其所占用的内存空间；</li>
</ol>
<h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><p>堆与栈都是内存中存放数据的地方；</p>
<ol>
<li>栈：栈内存主要用来存放基本类型的变量与引用变量，栈内存的管理是通过压栈和弹栈操作来完成的，以栈帧为基本单位来管理程序的调用关系，每当有函数调用时，都会通过压栈的方式创建新的栈帧，每当函数调用完毕时，再通过弹栈的方式释放栈帧。</li>
<li>堆：堆内存是用来存放运行时创建的对象。通过new关键字创建的对象都存在堆内存中。<em>JVM是基于堆栈的虚拟机，而每个java程序都运行在一个单独的JVM实例上，每一个实例对应一个堆，一个Java程序内的多个线程也都运行在同一个JVM实例上，因此这些线程之间会共享堆内存，鉴于此，多线程在访问堆中的数据时需要对数据进行同步；</em></li>
<li>在堆中产生一个数组或者对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或者对象在堆内存中的首地址，栈中的这个变量就成了数组或者对象的引用变量。引用变量就相当于为数组或者对象起的一个别称，以后可以在程序中使用栈中的引用变量来访问堆中的数组或变量，这就是Java中引用的用法；</li>
<li>从堆和栈的功能和作用来比较，堆主要是用来存放对象的，栈主要是用来执行程序的。<em>相较于堆，栈的存取速度更快</em>，但栈的大小和生存周期必须是确定的，因此缺乏灵活性。而堆却可以在运行时动态分配内存，生命生存期不用提前告诉编译器，但这也导致了其存储速度的缓慢；</li>
<li>在栈中存储的数据会通过压栈和弹栈操作在栈中回收，堆中的对象由垃圾回收器自动回收；</li>
</ol>
<h4 id="JavaCollections"><a href="#JavaCollections" class="headerlink" title="JavaCollections"></a>JavaCollections</h4><p>Java Collections框架包含了大量集合接口以及这些接口的实现类和操作他们的算法（例如排序、查找、反转、替换、复制、取最小元素、取最大元素等），具体而言，主要提供了List（列表）、Queue（队列）、Set（集合）、Stack（栈）和Map（映射表，用于存放键值对）等数据结构。<em>其中List、Queue、Set、Stack</em>都继承自Collection接口；<br><img src="http://wx3.sinaimg.cn/large/ace57effgy1fuwkberiytj210l0pab2a.jpg" alt="Collection接口"><br><img src="http://wx3.sinaimg.cn/large/ace57effgy1fuwkbh9ce3j20vt0lohdt.jpg" alt="Map接口"></p>
<ol>
<li>Set表示数学意义上的集合概念，其主要的是集合中的元素不能重复，一次放入Set中的每个元素都必需定义equals（）方法来确保对象的唯一性。有两个实现类，TreeSet（实现了SortSet接口，有序的），HashSet；</li>
<li>List又称为有序的Collection。它按照对象的进入顺序保存对象，可以保存重复的对象；实现类：ArrayList，Vector，LinkedList；</li>
<li>Map提供一个从键映射到值的数据结构。它用于保存键值对，其中值可以重复，但键是唯一的。实现类：HashMap，LinkedHashMap，TreeMap;</li>
</ol>
<ul>
<li><p>Iterator是一个对象，它的工作就是遍历并选择序列中的对象。用法是使用容器的iterator（）方法返回一个Iterator，然后通过Iterator的next（）方法返回第一个元素；hasNext（）方法判断是否还有下一个元素；remove（）方法删除迭代器返回的元素；</p>
</li>
<li><p>使用Iterator时出现ConcurrentModificationException是因为改变了容器中的元素数量，导致该异常，解决方法是将遍历过程中要删除的元素保存到一个集合中，等便利结束后再调用removeAll（）方法,或者使用itera.remove()方法；如在多线程环境下可以使用线程安全的容器（如ConcurrentHashMap和CopyOnWriteArrayList等）来替代非线程安全的容器；</p>
</li>
<li><p>Iterator只能正向遍历集合，适用于获取移除元素，针对于List，有ListIterator继承自Iterator，可以从两个方向来遍历List，同时支持元素的修改。</p>
</li>
</ul>
<h4 id="ArrayList、Vector、LinkedList"><a href="#ArrayList、Vector、LinkedList" class="headerlink" title="ArrayList、Vector、LinkedList"></a>ArrayList、Vector、LinkedList</h4><p>ArrayList、Vector、LinkedList均在java.util包中，均为可伸缩数组，即可以动态改变长度的数组；</p>
<ol>
<li>ArrayList和Vector都是基于存储元素的Object[] array来实现的，他们会在内存中开辟一块连续的空间来存储，正是因为数据存储是连续的，所以他们支持<em>用序号来访问元素，同时索引速度比较快，插入较慢</em>，因为需要将后面的元素全部移位；</li>
<li>LinkedList是采用双向列表来实现的，对数据的索引需要从列表头开始遍历，<em>因此对随机访问效率比较低，插入效率高</em>，因为不需要移动元素；</li>
</ol>
<h4 id="HashMap、HashTable、TreeMap、WeakHashMap"><a href="#HashMap、HashTable、TreeMap、WeakHashMap" class="headerlink" title="HashMap、HashTable、TreeMap、WeakHashMap"></a>HashMap、HashTable、TreeMap、WeakHashMap</h4><p>java中为数据结构中的映射定义了一个接口java.util.Map,它包括了3个实现类：HashMap、TreeMap、HashTable。Map用来存储键值对的数据结构，用来做索引的对象叫做Key，其对应的对象叫做Value；</p>
<ol>
<li>HashMap是HashTable的轻量级实现（非线程安全），他们都实现了Map接口，主要区别在于HashMap允许空键值（只允许一条存在），而HashTable不允许；</li>
<li>HashMap把HashTable的contains方法去掉了，改成了containsValue和containsKey；</li>
<li>HashTable的方法是线程安全的，而HashMap不是。就效率而言，HashMap可能高于HashTable。</li>
<li>HashMap使用Enumeration，HashMap使用Iterator；</li>
<li>hash值的使用不同，HashTable直接使用对象的hashcode；</li>
<li>一般来说，在Map中插入、删除和定位元素最好使用HashMap。由于TreeMap实现了SortMap接口，能够吧它保存的记录根据键排序，因此取出来后是排序后的键值对。如果需要按照自然排序和自定义排序用TreeMap更好；</li>
<li>LinkedHashMap是HashMap的子类，如果需要输出的顺讯和输入的顺序相同，那么用LinkedHashMap可以实现，还可以按读取顺序来排列；</li>
<li>WeakHashMap与HashMap类似，，不同之处在于其为弱引用方式，只要其中的Key不再被外界引用，他就会被垃圾回收器回收；而HashMap的Key是采用“强引用”方式，当HashMap中的Key没有被外界引用时，只有在这个Key从HashMap中删除后，才可以被垃圾回收器回收；</li>
<li>HashMap的同步可以通过Map m = Collection.synchronizedMap(new HashMap())来达到同步的效果；</li>
<li>向HashMap中添加Key时会调用hashCode（）生成一个hash值，如存在再比对equals（），如返回ture就覆盖，如返回false就添加；</li>
<li>如向HashMap中添加自定义类作为Key必须重写hashCode（）和equals（）！</li>
<li>从HashMap的工作原理可以看出，如果两个对象相等，那么这两个对象有着相同的hashCode，反之则不然；</li>
</ol>
<ul>
<li><p>Collection是一个集合接口，Collections是针对集合类的一个包装类；前者提供了为集合对象进行基本操作的通用接口方法。后者提供了一些列静态方法以实现对各种集合的搜索、排序、线程安全化等操作，其中绝大多数方法都是用来处理线性表，其不能被实例化，如同一个工具类，服务于Collection框架；</p>
</li>
<li><p>线程是指程序在执行过程中，能够执行代码的一个执行单元，有4种状态：运行、就绪、挂起和结束；</p>
</li>
<li><p>进程是指一段正在运行的程序，有事也被成为轻量级进程，它是程序执行的最小单元，<em>一个进程可以拥有多个线程，各个线程之间共享程序的内存空间（代码段、数据段和堆空间）以及一些进程级资源（如打开的文件）</em>，但是各个线程拥有自己的栈空间；</p>
</li>
<li><p>同步就是你喊我去吃饭，我如果听到了就和你去吃饭，如果我没有听到，你就不停地喊，直到我告诉你听到了，我们才一起去吃饭；异步就是你喊我，然后自己去吃饭，我听到后可能会立马起身跟你一起去，也有可能等到下班再去吃饭；</p>
</li>
</ul>
<h4 id="实现java多线程的方式"><a href="#实现java多线程的方式" class="headerlink" title="实现java多线程的方式"></a>实现java多线程的方式</h4><ol>
<li>继承Thread类，重写Run方法；Thread本质上也是实现了Runable接口的一个实例，它代表一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start（）方法，它将启动一个新线程，并执行run（）方法体中的代码。需要注意的是，调用start（）后并不是立即启动该线程，而是将该线程变为可运行状态（Runable），什么时候运行多线程代码是由操作系统决定的；</li>
<li>实现Runable接口，并实现该接口的run（）方法；启动线程时，依旧是创建Thread对象，用实现了Runable接口的对象作为参数实例化该Thread对象，再调用Thread的start（）方法； 其实，无论以上两种那种方法，都是通过Thread的对象的API来控制线程的；</li>
<li>实现Callable接口，重写call（）方法；Callable接口实际属于Executor框架中的功能类，Callable接口与Runable接口的功能类似，但提供了比Runable更强大的功能，一是主要是能够在任务结束后提供一个返回值，其他没有；二是call（）方法可以抛出异常，run（）方法不能；</li>
<li>一般实现多线程推荐实现Runable接口，很多开发人员认为<em>一个类仅在需要被加强或者修改时才会被继承</em>。因此，如果没有必要重写Thread类中的其他方法（Thread中提供了许多方法可以被子类使用或者重写），最好使用实现Runable接口的方式创建线程；</li>
</ol>
<ul>
<li>系统通过调用线程类的start（）方法启动一个线程，此时线程就处于就绪状态，意味着可供JVM来调度运行，调度过程中，JVM通过调用线程类的run()方法来完成实际操作；只调用run（）方法是不行的，依旧是单线程；</li>
</ul>
<h4 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h4><ol>
<li>synchronized关键字；再java中每个对象都有一个对象锁与之相关联，该锁表明对象在任何时候只允许被一个线程所拥有，但一个线程调用对象的一段synchronized代码时，需要先获取这个锁，然后去执行相应代码，执行结束后，释放锁；synchronized关键字有两种用法一个是synchronized方法（在方法的声明前加入synchronized关键字）和synchronized代码块（synchronized后跟大括号，其中为需要同步的代码块），前者有一弊病，当方法规模非常庞大时，会大大影响程序的运行效率，所以最好还是使用synchronized代码块；</li>
<li>wait()、notify（）方法；它们是Object的本地final方法，无法被重写。在synchronized代码被执行期间，wait表示线程的等待，调用该方法会导致线程阻塞，直至另一线程调用notify或notifyAll方法才可令其继续执行；</li>
<li>从java5开始，可以使用Lock机制取代synchronized 代码块和synchronized 方法。以及使用Condition接口对象的await,signal,signalAll方法取代Object类中的wait,notify,notifyAll方法；e.g<br><img src="http://wx4.sinaimg.cn/large/ace57effgy1fuxoiyp3j0j20h70ikdjn.jpg" alt="生产者模型"><br><img src="http://wx4.sinaimg.cn/large/ace57effgy1fuxoiz4y31j20ho0e7jtf.jpg" alt="消费者模型"></li>
</ol>
<ul>
<li>sleep（）是使线程暂停一段时间的方法；他与wait（）的区别一是线程用来控制自身流程的，他会使此线程暂停一段时间，吧执行机会让给其他线程，等到计时时间到，此线程会自动“苏醒”，不用等待其他线程调用notify（）方法来唤醒；二是sleep（）方法不会释放锁，wait（）方法会释放锁；三是sleep（）可以在任何地方使用，不用非要在synchronized代码块中使用；四是sleep（）必须捕获异常；五是容易导致死锁，所以<em>一般情况下不推荐使用sleep（）方法</em>；且睡眠时间到了之后不是立即回到运行状态，而是可运行状态；</li>
</ul>
<h4 id="synchronized和Lock的异同"><a href="#synchronized和Lock的异同" class="headerlink" title="synchronized和Lock的异同"></a>synchronized和Lock的异同</h4><ol>
<li>用法不一样；synchronized加在方法上或者特定代码块上，托管给JVM执行的；而Lock需要显式指定起始位置和终止位置，且是通过代码实现的，有比synchronized更加精确的线程语义；</li>
<li>性能不一样；在java5增加了一个Lock接口的实现类ReentrantLock，他和synchronized在不同的情况下会有不同的表现。在竞争不激烈的情况下，synchronized性能会优于ReentrantLock，但在竞争激烈的情况下，synchronized性能会急剧下降，而ReentrantLock的性能基本保持不变；</li>
<li>锁机制不一样；synchronized获得锁和释放锁都在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁，不会因为出现异常而出现死锁。而Lock需要开发人员手动释放，并且必须在finally中释放，否则死锁；</li>
</ol>
<ul>
<li>当一个线程进入一个对像的synchronized方法后，其他线程是可以进入同一对象非synchronized方法的，也可以调用static修饰的synchronized方法（他的锁是当前类的字节码，非static的是this）；如果这个对象内部调用了wait（）方法，那么其他线程可以访问同一对象的其他synchronized方法。如果这个对象没有使用wait（）方法，并且其他方法都为synchronized（）方法，那么其他线程就无法访问；</li>
</ul>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">Show TOC</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">Hide TOC</button>
  <div class="random-toc">
    <h2>Table of Content</h2>
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#重载和覆盖的区别："><span class="toc-text">重载和覆盖的区别：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#小结"><span class="toc-text">小结:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口与抽象类："><span class="toc-text">接口与抽象类：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#小结："><span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么时候使用抽象类和接口？"><span class="toc-text">什么时候使用抽象类和接口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象的主要特征包括抽象、继承、封装和多态："><span class="toc-text">面向对象的主要特征包括抽象、继承、封装和多态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承有如下特点："><span class="toc-text">继承有如下特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多态的实现机制："><span class="toc-text">多态的实现机制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#break、continue以及return的区别："><span class="toc-text">break、continue以及return的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final、finally和finalize的区别："><span class="toc-text">final、finally和finalize的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Static关键字的作用"><span class="toc-text">Static关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#值传递与引用传递的区别"><span class="toc-text">值传递与引用传递的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String、StringBuffer、StringBuilder和StringTokenized的区别"><span class="toc-text">String、StringBuffer、StringBuilder和StringTokenized的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java异常处理机制"><span class="toc-text">java异常处理机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throw与throws的比较"><span class="toc-text">throw与throws的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类的加载步骤"><span class="toc-text">类的加载步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一维数组和二维数组"><span class="toc-text">一维数组和二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存泄漏"><span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆和栈的区别"><span class="toc-text">堆和栈的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaCollections"><span class="toc-text">JavaCollections</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList、Vector、LinkedList"><span class="toc-text">ArrayList、Vector、LinkedList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap、HashTable、TreeMap、WeakHashMap"><span class="toc-text">HashMap、HashTable、TreeMap、WeakHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现java多线程的方式"><span class="toc-text">实现java多线程的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程同步"><span class="toc-text">多线程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized和Lock的异同"><span class="toc-text">synchronized和Lock的异同</span></a></li></ol>
  </div>
</div>

  
<nav id="pagination">
  

  

  
    <a href="/2018/08/12/Linux常用命令/" class="next">Next post Linux常用命令 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Alan Haze using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/volvo.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/AlanHaze">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://twitter.com/alanhaze2">
        
          <i class="icon iconfont twitter">&#xe600;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://www.zhihu.com/people/tang-dun/activities">
        
          <i class="icon iconfont zhihu">&#xe60b;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://plus.google.com/u/0/107452576753639843741">
        
          <i class="icon iconfont google-plus">&#xe603;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["slideLeft2","slideRight2","flash2"],"timer":true,"delay":5000,"shuffle":true,"count":28};
var unsplashConfig = {"blur":false,"gravity":"north"};
// is show background images
var turnoffBackgroundImage = false;



  turnoffBackgroundImage = true;


var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

